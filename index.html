<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Simulación 3D — Mesa de billar y 2 bolas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; background: #0c0f13; color: #e9eef5; font-family: system-ui, sans-serif; }
    #app { position: relative; height: 100%; }
    canvas { display: block; }
    .hud {
      position: absolute; left: 12px; bottom: 12px;
      background: rgba(0,0,0,.45); backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,.08); border-radius: 10px;
      padding: 10px 12px; font-size: 14px; line-height: 1.35;
    }
    .hud b { font-weight: 700; }
    .legend {
      display: inline-grid; grid-template-columns: auto 1fr; gap: 6px 10px; margin-top: 6px;
    }
    .swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #0007; }
    .swatch.felt { background: #1a7a41; }
    .swatch.ball1 { background: #ffffff; }
    .swatch.ball2 { background: #d61e1e; }
    .dim {
      position: absolute; color: #ffffff; font-size: 12px; letter-spacing: .2px;
      text-shadow: 0 1px 2px #000;
      padding: 2px 6px; border-radius: 6px; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.08);
    }
    .dim.h { left: 50%; transform: translateX(-50%); bottom: 56px; }
    .dim.v { top: 50%; transform: translateY(-50%); right: 18px; writing-mode: vertical-rl; text-orientation: mixed; }
    .tip {
      position: absolute; right: 12px; bottom: 12px; opacity: .85; font-size: 12px;
      background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.12);
      padding: 8px 10px; border-radius: 8px;
    }
    a { color: #9fd2ff; text-decoration: none; }
  </style>
</head>
<body>
  <div id="app">
    <div class="hud">
      <div><b>Mesa de billar (superficie de juego)</b></div>
      <div>Medidas reales: 2.84&nbsp;m × 1.42&nbsp;m (9&nbsp;pies, proporción 2:1)</div>
      <div>Diámetro estándar de bola: 57.15&nbsp;mm (radio 28.575&nbsp;mm)</div>
      <div class="legend" aria-hidden="true" title="Leyenda de colores">
        <div class="swatch felt"></div><div>Paño</div>
        <div class="swatch ball1"></div><div>Bola blanca</div>
        <div class="swatch ball2"></div><div>Bola roja (ejemplo)</div>
      </div>
    </div>
    <div class="dim h">2.84 m</div>
    <div class="dim v">1.42 m</div>
    <div class="tip">Arrastra para rotar · Rueda/Pinch para zoom · Click derecho para desplazar</div>
  </div>

  <!-- Three.js con módulos ES -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.158/examples/jsm/controls/OrbitControls.js";

    // --- Escena, cámara, renderer ---
    const app = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0f13);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 100);
    // Usamos unidades métricas reales: 1 unidad = 1 metro
    camera.position.set(3.2, 1.9, 3.2);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    // --- Controles de órbita ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.minDistance = 0.4;  // evita atravesar la mesa
    controls.maxDistance = 10;
    controls.target.set(0, 0.45, 0);

    // --- Iluminación ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
    keyLight.position.set(3, 5, 2);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    keyLight.shadow.camera.near = 0.1;
    keyLight.shadow.camera.far = 20;
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0x88aaff, 0.35);
    rimLight.position.set(-2.5, 3.5, -3);
    scene.add(rimLight);

    // --- Medidas reales de la mesa (superficie de juego) ---
    const tableLength = 2.84; // metros (9 ft)
    const tableWidth  = 1.42; // metros
    const feltThickness = 0.02; // 2 cm de "cuerpo" para recibir sombras
    const railWidth = 0.08; // 8 cm de banda/arrietes alrededor (visual)

    // --- Superficie del paño (plano extruido) ---
    const feltGeom = new THREE.BoxGeometry(tableLength, feltThickness, tableWidth);
    const feltMat = new THREE.MeshPhongMaterial({ color: 0x1a7a41, shininess: 30, specular: 0x244c2c });
    const felt = new THREE.Mesh(feltGeom, feltMat);
    felt.receiveShadow = true;
    felt.castShadow = false;
    felt.position.y = feltThickness / 2;
    scene.add(felt);

    // --- Marcos/bandas alrededor (sólo visual) ---
    const railMat = new THREE.MeshPhongMaterial({ color: 0x5b3a1e, shininess: 10 });
    // piezas: arriba, abajo, izquierda, derecha
    const mkRail = (lenX, lenZ, x, z) => {
      const g = new THREE.BoxGeometry(lenX, 0.07, lenZ);
      const m = new THREE.Mesh(g, railMat);
      m.position.set(x, felt.position.y + 0.07/2, z);
      m.castShadow = true; m.receiveShadow = true;
      scene.add(m);
    };
    mkRail(tableLength + railWidth*2, railWidth, 0,  tableWidth/2 + railWidth/2); // arriba
    mkRail(tableLength + railWidth*2, railWidth, 0, -tableWidth/2 - railWidth/2); // abajo
    mkRail(railWidth, tableWidth,  tableLength/2 + railWidth/2, 0); // derecha
    mkRail(railWidth, tableWidth, -tableLength/2 - railWidth/2, 0); // izquierda

    // --- Líneas blancas finas para enmarcar la superficie de juego ---
    const edgeGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(tableLength, 0.0001, tableWidth));
    const edgeMat  = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 });
    const edges = new THREE.LineSegments(edgeGeom, edgeMat);
    edges.position.y = felt.position.y + feltThickness/2 + 0.001;
    scene.add(edges);

    // --- Suelo sutil para las sombras ---
    const groundGeom = new THREE.PlaneGeometry(20, 20);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.18 });
    const ground = new THREE.Mesh(groundGeom, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Bolas (diámetro 57.15 mm => radio 28.575 mm) ---
    const ballRadius = 0.028575; // metros
    const ballGeom = new THREE.SphereGeometry(ballRadius, 48, 48);

    const ballWhiteMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff, roughness: 0.2, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.05
    });
    const ballRedMat = new THREE.MeshPhysicalMaterial({
      color: 0xd61e1e, roughness: 0.2, metalness: 0.0, clearcoat: 1.0, clearcoatRoughness: 0.05
    });

    const placeBall = (x, z, mat) => {
      const s = new THREE.Mesh(ballGeom, mat);
      s.castShadow = true; s.receiveShadow = false;
      s.position.set(x, felt.position.y + ballRadius, z);
      scene.add(s);
      return s;
    };

    // Posiciones iniciales (sobre el paño, sin colisiones)
    const ball1 = placeBall(-0.4, 0, ballWhiteMat); // blanca
    const ball2 = placeBall( 0.4, 0.2, ballRedMat); // roja (de ejemplo)

    // --- Ejes de referencia opcional (tecla H para alternar) ---
    const axes = new THREE.AxesHelper(0.5);
    axes.visible = false;
    scene.add(axes);
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'h') axes.visible = !axes.visible;
    });

    // --- Ajuste de vista inicial ---
    controls.update();

    // --- Resize ---
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onResize);

    // --- Animación (sólo para render interactivo, sin mover objetos) ---
    renderer.setAnimationLoop(() => {
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
